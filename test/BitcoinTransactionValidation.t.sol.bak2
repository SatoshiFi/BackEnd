// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../contracts/src/MiningPoolDAO.sol";
import "../contracts/src/libs/BitcoinUtils.sol";
import "../contracts/src/core/BitcoinTxParser.sol";

/**
 * @title BitcoinTransactionValidation
 * @notice Детальная проверка создания Bitcoin транзакций для redemption
 */
contract BitcoinTransactionValidationTest is Test {

    // Test vectors from Bitcoin mainnet
    bytes32 constant TEST_TXID = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;
    uint32 constant TEST_VOUT = 0;
    uint64 constant TEST_AMOUNT = 100000000; // 1 BTC
    uint64 constant TEST_FEE = 10000; // 0.0001 BTC

    // Bitcoin scripts
    bytes constant P2PKH_SCRIPT = hex"76a914" // OP_DUP OP_HASH160
                                   hex"89abcdefabbaabbaabbaabbaabbaabbaabbaabba" // pubkey hash
                                   hex"88ac"; // OP_EQUALVERIFY OP_CHECKSIG

    bytes constant P2WPKH_SCRIPT = hex"0014" // OP_0 + 20 bytes
                                    hex"89abcdefabbaabbaabbaabbaabbaabbaabbaabba"; // witness pubkey hash

    bytes constant P2SH_SCRIPT = hex"a914" // OP_HASH160
                                  hex"89abcdefabbaabbaabbaabbaabbaabbaabbaabba" // script hash
                                  hex"87"; // OP_EQUAL

    function setUp() public {
        console.log("=== Bitcoin Transaction Validation Tests ===");
    }

    /**
     * @notice Test 1: Проверка корректного построения non-witness транзакции
     */
    function testBuildNonWitnessTransaction() public {
        console.log("\n[Test 1] Building Non-Witness Transaction");

        // Create test MiningPoolDAO to access internal function
        TestMiningPoolDAO dao = new TestMiningPoolDAO();

        // Build transaction with one input and two outputs (payment + change)
        uint64 payoutValue = 90000000; // 0.9 BTC
        uint64 changeValue = TEST_AMOUNT - payoutValue - TEST_FEE;

        bytes memory tx = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            payoutValue,
            P2PKH_SCRIPT,
            changeValue,
            P2PKH_SCRIPT
        );

        // Verify transaction structure
        assertGt(tx.length, 0, "Transaction should not be empty");

        // Check version (first 4 bytes should be 0x02000000 for version 2)
        bytes4 version = bytes4(tx);
        assertEq(version, hex"02000000", "Version should be 2");

        // Calculate transaction ID
        bytes32 txid = BitcoinUtils.doubleSha256(tx);
        console.log("  Generated TXID:", uint256(txid));

        // Verify transaction is deterministic
        bytes memory tx2 = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            payoutValue,
            P2PKH_SCRIPT,
            changeValue,
            P2PKH_SCRIPT
        );
        assertEq(keccak256(tx), keccak256(tx2), "Transaction building should be deterministic");

        console.log("  [OK] Transaction built successfully");
        console.log("  [OK] Transaction size:", tx.length, "bytes");
    }

    /**
     * @notice Test 2: Проверка sighash вычисления для подписи
     */
    function testSighashComputation() public {
        console.log("\n[Test 2] Sighash Computation");

        TestMiningPoolDAO dao = new TestMiningPoolDAO();

        uint64 payoutValue = 50000000; // 0.5 BTC
        uint64 changeValue = 49990000; // ~0.4999 BTC

        // Build transaction
        bytes memory tx = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            payoutValue,
            P2PKH_SCRIPT,
            changeValue,
            P2PKH_SCRIPT
        );

        // Compute sighash (double SHA256)
        bytes32 sighash = BitcoinUtils.doubleSha256(tx);
        console.log("  Sighash:", uint256(sighash));

        // Verify sighash is 32 bytes
        assertEq(uint256(sighash) > 0, true, "Sighash should not be zero");

        // Test that different transactions produce different sighashes
        bytes memory tx2 = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            payoutValue + 1000, // Different amount
            P2PKH_SCRIPT,
            changeValue - 1000,
            P2PKH_SCRIPT
        );

        bytes32 sighash2 = BitcoinUtils.doubleSha256(tx2);
        assertTrue(sighash != sighash2, "Different transactions should have different sighashes");

        console.log("  [OK] Sighash computed correctly");
    }

    /**
     * @notice Test 3: Проверка различных типов Bitcoin скриптов
     */
    function testDifferentScriptTypes() public {
        console.log("\n[Test 3] Different Script Types");

        TestMiningPoolDAO dao = new TestMiningPoolDAO();
        uint64 amount = 10000000; // 0.1 BTC

        // Test P2PKH (Pay to Public Key Hash)
        console.log("  Testing P2PKH...");
        bytes memory txP2PKH = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            amount,
            P2PKH_SCRIPT,
            0,
            ""
        );
        assertGt(txP2PKH.length, 0, "P2PKH transaction should be valid");
        console.log("    [OK] P2PKH transaction size:", txP2PKH.length);

        // Test P2WPKH (Pay to Witness Public Key Hash)
        console.log("  Testing P2WPKH...");
        bytes memory txP2WPKH = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            amount,
            P2WPKH_SCRIPT,
            0,
            ""
        );
        assertGt(txP2WPKH.length, 0, "P2WPKH transaction should be valid");
        console.log("    [OK] P2WPKH transaction size:", txP2WPKH.length);

        // Test P2SH (Pay to Script Hash)
        console.log("  Testing P2SH...");
        bytes memory txP2SH = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            amount,
            P2SH_SCRIPT,
            0,
            ""
        );
        assertGt(txP2SH.length, 0, "P2SH transaction should be valid");
        console.log("    [OK] P2SH transaction size:", txP2SH.length);
    }

    /**
     * @notice Test 4: Проверка VarInt кодирования
     */
    function testVarIntEncoding() public {
        console.log("\n[Test 4] VarInt Encoding");

        TestMiningPoolDAO dao = new TestMiningPoolDAO();

        // Test small values (< 0xFD)
        bytes memory vi1 = dao.encodeVarInt(100);
        assertEq(vi1.length, 1, "Small value should use 1 byte");
        assertEq(uint8(vi1[0]), 100, "Value should be encoded directly");
        console.log("  [OK] Small value (100) encoded in 1 byte");

        // Test medium values (0xFD - 0xFFFF)
        bytes memory vi2 = dao.encodeVarInt(1000);
        assertEq(vi2.length, 3, "Medium value should use 3 bytes");
        assertEq(uint8(vi2[0]), 0xFD, "Should start with 0xFD");
        console.log("  [OK] Medium value (1000) encoded in 3 bytes");

        // Test large values (0x10000 - 0xFFFFFFFF)
        bytes memory vi3 = dao.encodeVarInt(100000);
        assertEq(vi3.length, 5, "Large value should use 5 bytes");
        assertEq(uint8(vi3[0]), 0xFE, "Should start with 0xFE");
        console.log("  [OK] Large value (100000) encoded in 5 bytes");
    }


    /**
     * @notice Test 6: Проверка multi-output транзакций
     */
    function testMultiOutputTransaction() public {
        console.log("\n[Test 6] Multi-Output Transaction");

        TestMiningPoolDAO dao = new TestMiningPoolDAO();

        // Test with multiple outputs (batched redemption scenario)
        uint64[] memory amounts = new uint64[](3);
        amounts[0] = 30000000; // 0.3 BTC
        amounts[1] = 20000000; // 0.2 BTC
        amounts[2] = 10000000; // 0.1 BTC

        uint64 totalPayout = amounts[0] + amounts[1] + amounts[2];
        uint64 changeAmount = TEST_AMOUNT - totalPayout - TEST_FEE;

        // Build transaction with main output and change
        bytes memory tx = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            totalPayout,
            P2PKH_SCRIPT,
            changeAmount,
            P2PKH_SCRIPT
        );

        assertGt(tx.length, 100, "Multi-output transaction should be valid size");

        // Calculate fee
        uint64 impliedFee = TEST_AMOUNT - totalPayout - changeAmount;
        assertEq(impliedFee, TEST_FEE, "Fee calculation should be correct");

        console.log("  [OK] Multi-output transaction built");
        console.log("  [OK] Total payout:", totalPayout);
        console.log("  [OK] Change amount:", changeAmount);
        console.log("  [OK] Fee:", impliedFee);
    }

    /**
     * @notice Test 7: Проверка edge cases
     */
    function testEdgeCases() public {
        console.log("\n[Test 7] Edge Cases");

        TestMiningPoolDAO dao = new TestMiningPoolDAO();

        // Test 1: Zero change (no change output)
        console.log("  Testing zero change...");
        bytes memory txNoChange = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            TEST_AMOUNT - TEST_FEE, // Entire amount minus fee
            P2PKH_SCRIPT,
            0, // No change
            ""
        );
        assertGt(txNoChange.length, 0, "Transaction with no change should be valid");
        console.log("    [OK] Transaction with no change built");

        // Test 2: Minimum dust amount
        console.log("  Testing dust amount...");
        uint64 dustAmount = 546; // Bitcoin dust limit in satoshis
        bytes memory txDust = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            dustAmount,
            P2PKH_SCRIPT,
            0,
            ""
        );
        assertGt(txDust.length, 0, "Transaction with dust amount should be valid");
        console.log("    [OK] Transaction with dust amount built");

        // Test 3: Maximum values
        console.log("  Testing maximum values...");
        uint64 maxAmount = 21000000 * 100000000; // 21M BTC in satoshis
        bytes memory txMax = dao.buildNonWitnessTx(
            TEST_TXID,
            TEST_VOUT,
            maxAmount,
            P2PKH_SCRIPT,
            0,
            ""
        );
        assertGt(txMax.length, 0, "Transaction with max amount should be valid");
        console.log("    [OK] Transaction with max amount built");
    }
}

/**
 * @dev Test helper contract to expose internal functions
 */
contract TestMiningPoolDAO {

    function buildNonWitnessTx(
        bytes32 prevTxId,
        uint32 prevVout,
        uint64 payoutValue,
        bytes memory payoutScript,
        uint64 changeValue,
        bytes memory changeScript
    ) public pure returns (bytes memory) {
        return _buildNonWitnessTx(prevTxId, prevVout, payoutValue, payoutScript, changeValue, changeScript);
    }

    function encodeVarInt(uint256 v) public pure returns (bytes memory) {
        return _encodeVarInt(v);
    }

    // Internal functions from MiningPoolDAO
    function _buildNonWitnessTx(
        bytes32 prevTxIdBE,
        uint32 prevVout,
        uint64 payoutValue,
        bytes memory payoutScript,
        uint64 changeValue,
        bytes memory changeScript
    ) internal pure returns (bytes memory) {
        bytes memory ver = _toLE32(2);

        // vin
        bytes memory vinCount = _encodeVarInt(1);
        bytes32 prev = _reverse32(prevTxIdBE);
        bytes memory voutIdx = _toLE32(prevVout);
        bytes memory scriptLen0 = _encodeVarInt(0);
        bytes memory seq = _toLE32(0xFFFFFFFF);
        bytes memory vin = abi.encodePacked(prev, voutIdx, scriptLen0, seq);

        // vouts
        uint256 voutCountNum = changeValue > 0 ? 2 : 1;
        bytes memory voutCount = _encodeVarInt(voutCountNum);
        bytes memory out1Val = _toLE64(payoutValue);
        bytes memory out1ScriptLen = _encodeVarInt(payoutScript.length);
        bytes memory out1 = abi.encodePacked(out1Val, out1ScriptLen, payoutScript);

        bytes memory outs;
        if (changeValue > 0) {
            bytes memory out2Val = _toLE64(changeValue);
            bytes memory out2ScriptLen = _encodeVarInt(changeScript.length);
            bytes memory out2 = abi.encodePacked(out2Val, out2ScriptLen, changeScript);
            outs = abi.encodePacked(out1, out2);
        } else {
            outs = out1;
        }

        bytes memory lock = _toLE32(0);

        return abi.encodePacked(ver, vinCount, vin, voutCount, outs, lock);
    }

    function _encodeVarInt(uint256 v) internal pure returns (bytes memory) {
        if (v < 0xFD) {
            bytes memory o = new bytes(1);
            o[0] = bytes1(uint8(v));
            return o;
        } else if (v <= 0xFFFF) {
            bytes memory o = new bytes(3);
            o[0] = 0xFD;
            o[1] = bytes1(uint8(v & 0xFF));
            o[2] = bytes1(uint8((v >> 8) & 0xFF));
            return o;
        } else if (v <= 0xFFFFFFFF) {
            bytes memory o = new bytes(5);
            o[0] = 0xFE;
            for (uint i = 0; i < 4; i++) o[1+i] = bytes1(uint8((v >> (8*i)) & 0xFF));
            return o;
        } else {
            bytes memory o = new bytes(9);
            o[0] = 0xFF;
            for (uint i = 0; i < 8; i++) o[1+i] = bytes1(uint8((v >> (8*i)) & 0xFF));
            return o;
        }
    }

    function _toLE32(uint32 v) internal pure returns (bytes memory) {
        bytes memory o = new bytes(4);
        for (uint i = 0; i < 4; i++) {
            o[i] = bytes1(uint8(v >> (8 * i)));
        }
        return o;
    }

    function _toLE64(uint64 v) internal pure returns (bytes memory) {
        bytes memory o = new bytes(8);
        for (uint i = 0; i < 8; i++) {
            o[i] = bytes1(uint8(v >> (8 * i)));
        }
        return o;
    }

    function _reverse32(bytes32 input) internal pure returns (bytes32) {
        bytes32 result;
        for (uint i = 0; i < 32; i++) {
            result |= bytes32(uint256(uint8(input[i])) << (8 * (31 - i)));
        }
        return result;
    }
}